{"version":3,"file":"ethereumTypes.js","sourceRoot":"","sources":["../../ts/types/ethereumTypes.ts"],"names":[],"mappings":"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","sourcesContent":["import * as t from 'funtypes'\n\nconst BigIntParser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: (value) => {\n\t\tif (!/^0x([a-fA-F0-9]{1,64})$/.test(value))\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `${value} is not a hex string encoded number.`,\n\t\t\t}\n\t\telse return { success: true, value: BigInt(value) }\n\t},\n\tserialize: (value) => {\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.` }\n\t\treturn { success: true, value: `0x${value.toString(16)}` }\n\t},\n}\n\nexport const AddressParser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: (value) => {\n\t\tif (!/^0x([a-fA-F0-9]{40})$/.test(value))\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `${value} is not a hex string encoded address.`,\n\t\t\t}\n\t\telse return { success: true, value: BigInt(value) }\n\t},\n\tserialize: (value) => {\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.` }\n\t\treturn { success: true, value: `0x${value.toString(16).padStart(40, '0')}` }\n\t},\n}\n\nconst Bytes32Parser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: (value) => {\n\t\tif (!/^0x([a-fA-F0-9]{64})$/.test(value))\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `${value} is not a hex string encoded 32 byte value.`,\n\t\t\t}\n\t\telse return { success: true, value: BigInt(value) }\n\t},\n\tserialize: (value) => {\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.` }\n\t\treturn { success: true, value: `0x${value.toString(16).padStart(64, '0')}` }\n\t},\n}\n\nexport const BytesParser: t.ParsedValue<t.String, Uint8Array>['config'] = {\n\tparse: (value) => {\n\t\tconst match = /^(?:0x)?([a-fA-F0-9]*)$/.exec(value)\n\t\tif (match === null)\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Expected a hex string encoded byte array with an optional '0x' prefix but received ${value}`,\n\t\t\t}\n\t\tconst normalized = match[1]\n\t\tif (normalized.length % 2)\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Hex string encoded byte array must be an even number of charcaters long.`,\n\t\t\t}\n\t\tconst bytes = new Uint8Array(normalized.length / 2)\n\t\tfor (let i = 0; i < normalized.length; i += 2) {\n\t\t\tbytes[i / 2] = Number.parseInt(`${normalized[i]}${normalized[i + 1]}`, 16)\n\t\t}\n\t\treturn { success: true, value: new Uint8Array(bytes) }\n\t},\n\tserialize: (value) => {\n\t\tif (!(value instanceof Uint8Array)) return { success: false, message: `${typeof value} is not a Uint8Array.` }\n\t\tlet result = ''\n\t\tfor (let i = 0; i < value.length; ++i) {\n\t\t\tresult += ('0' + value[i].toString(16)).slice(-2)\n\t\t}\n\t\treturn { success: true, value: `0x${result}` }\n\t},\n}\n\nconst OptionalBytesParser: t.ParsedValue<t.Union<[t.String, t.Literal<undefined>]>, Uint8Array>['config'] = {\n\tparse: (value) => BytesParser.parse(value || '0x'),\n\tserialize: (value) => BytesParser.serialize!(value || new Uint8Array()),\n}\n\nexport const LiteralConverterParserFactory: <TInput, TOutput>(input: TInput, output: TOutput) => t.ParsedValue<t.Runtype<TInput>, TOutput>['config'] = (\n\tinput,\n\toutput,\n) => {\n\treturn {\n\t\tparse: (value) => (value === input ? { success: true, value: output } : { success: false, message: `${value} was expected to be literal.` }),\n\t\tserialize: (value) => (value === output ? { success: true, value: input } : { success: false, message: `${value} was expected to be literal.` }),\n\t}\n}\n\nconst SmallIntParser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: value => {\n\t\tif (!/^0x([a-fA-F0-9]{1,64})$/.test(value)) return { success: false, message: `${value} is not a hex string encoded number.` }\n\t\tif (BigInt(value) >= 2n**64n) return { success: false, message: `${value} must be smaller than 2^64.` }\n\t\treturn { success: true, value: BigInt(value) }\n\t},\n\tserialize: value => {\n\t\tif (value >= 2n**64n) return { success: false, message: `${value} must be smaller than 2^64.` }\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.`}\n\t\treturn { success: true, value: `0x${value.toString(16)}` }\n\t},\n}\n\nconst TimestampParser: t.ParsedValue<t.String, Date>['config'] = {\n\tparse: value => {\n\t\tif (!/^0x([a-fA-F0-9]{0,8})$/.test(value)) return { success: false, message: `${value} is not a hex string encoded timestamp.` }\n\t\treturn { success: true, value: new Date(Number.parseInt(value, 16) * 1000) }\n\t},\n\tserialize: value => {\n\t\tif (!(value instanceof Date)) return { success: false, message: `${typeof value} is not a Date.`}\n\t\treturn { success: true, value: `0x${Math.floor(value.valueOf() / 1000).toString(16)}` }\n\t},\n}\n\nexport const EthereumQuantity = t.String.withParser(BigIntParser)\nexport type EthereumQuantity = t.Static<typeof EthereumQuantity>\n\nexport const EthereumData = t.String.withParser(BytesParser)\nexport type EthereumData = t.Static<typeof EthereumData>\n\nexport const EthereumAddress = t.String.withParser(AddressParser)\nexport type EthereumAddress = t.Static<typeof EthereumAddress>\n\nexport const EthereumBytes32 = t.String.withParser(Bytes32Parser)\nexport type EthereumBytes32 = t.Static<typeof EthereumBytes32>\n\nexport const EthereumInput = t.Union(t.String, t.Undefined).withParser(OptionalBytesParser)\nexport type EthereumInput = t.Static<typeof EthereumInput>\n\nexport const EthereumQuantitySmall = t.String.withParser(SmallIntParser)\nexport type EthereumQuantitySmall = t.Static<typeof EthereumQuantitySmall>\n\nexport const EthereumTimestamp = t.String.withParser(TimestampParser)\nexport type EthereumTimestamp = t.Static<typeof EthereumTimestamp>\n\nexport const EthereumAccessList = t.ReadonlyArray(\n\tt.ReadonlyObject({\n\t\taddress: EthereumAddress,\n\t\tstorageKeys: t.ReadonlyArray(EthereumBytes32)\n\t}).asReadonly()\n)\nexport type EthereumAccessList = t.Static<typeof EthereumAccessList>\n\nexport const EthereumBlockTag = t.Union(EthereumQuantitySmall, EthereumBytes32, t.Literal('latest'), t.Literal('pending'))\nexport type EthereumBlockTag = t.Static<typeof EthereumBlockTag>\n\nexport type UnionToIntersection<T> = (T extends unknown ? (k: T) => void : never) extends (k: infer I) => void ? I : never\n\ntype ToWireType<T> =\n\tT extends t.Intersect<infer U> ? UnionToIntersection<{ [I in keyof U]: ToWireType<U[I]> }[number]>\n\t: T extends t.Union<infer U> ? { [I in keyof U]: ToWireType<U[I]> }[number]\n\t: T extends t.Record<infer U, infer V> ? Record<t.Static<U>, ToWireType<V>>\n\t: T extends t.Partial<infer U, infer V> ? V extends true ? { readonly [K in keyof U]?: ToWireType<U[K]> } : { [K in keyof U]?: ToWireType<U[K]> }\n\t: T extends t.Object<infer U, infer V> ? V extends true ? { readonly [K in keyof U]: ToWireType<U[K]> } : { [K in keyof U]: ToWireType<U[K]> }\n\t: T extends t.Readonly<t.Tuple<infer U>> ? { readonly [P in keyof U]: ToWireType<U[P]>}\n\t: T extends t.Tuple<infer U> ? { [P in keyof U]: ToWireType<U[P]>}\n\t: T extends t.ReadonlyArray<infer U> ? readonly ToWireType<U>[]\n\t: T extends t.Array<infer U> ? ToWireType<U>[]\n\t: T extends t.ParsedValue<infer U, infer _> ? ToWireType<U>\n\t: T extends t.Codec<infer U> ? U\n\t: never\n\nexport function serialize<T, U extends t.Codec<T>>(funtype: U, value: T) {\n\treturn funtype.serialize(value) as ToWireType<U>\n}\n"]}