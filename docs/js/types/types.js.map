{"version":3,"file":"types.js","sourceRoot":"","sources":["../../ts/types/types.ts"],"names":[],"mappings":"AAIA,MAAM,UAAU,SAAS,CAA0B,OAAU,EAAE,KAAQ;IACtE,OAAO,OAAO,CAAC,SAAS,CAAC,KAAK,CAAkB,CAAA;AACjD,CAAC","sourcesContent":["import { Wallet } from 'ethers'\nimport * as t from 'funtypes'\nimport { TransactionList } from './bouquetTypes.js'\n\nexport function serialize<T, U extends t.Codec<T>>(funtype: U, value: T) {\n\treturn funtype.serialize(value) as ToWireType<U>\n}\n\nexport type UnionToIntersection<T> = (T extends unknown ? (k: T) => void : never) extends (k: infer I) => void ? I : never\n\nexport type ToWireType<T> = T extends t.Intersect<infer U>\n\t? UnionToIntersection<{ [I in keyof U]: ToWireType<U[I]> }[number]>\n\t: T extends t.Union<infer U>\n\t? { [I in keyof U]: ToWireType<U[I]> }[number]\n\t: T extends t.Record<infer U, infer V>\n\t? Record<t.Static<U>, ToWireType<V>>\n\t: T extends t.Partial<infer U, infer V>\n\t? V extends true\n\t? { readonly [K in keyof U]?: ToWireType<U[K]> }\n\t: { [K in keyof U]?: ToWireType<U[K]> }\n\t: T extends t.Object<infer U, infer V>\n\t? V extends true\n\t? { readonly [K in keyof U]: ToWireType<U[K]> }\n\t: { [K in keyof U]: ToWireType<U[K]> }\n\t: T extends t.Readonly<t.Tuple<infer U>>\n\t? { readonly [P in keyof U]: ToWireType<U[P]> }\n\t: T extends t.Tuple<infer U>\n\t? { [P in keyof U]: ToWireType<U[P]> }\n\t: T extends t.ReadonlyArray<infer U>\n\t? readonly ToWireType<U>[]\n\t: T extends t.Array<infer U>\n\t? ToWireType<U>[]\n\t: T extends t.ParsedValue<infer U, infer _>\n\t? ToWireType<U>\n\t: T extends t.Codec<infer U>\n\t? U\n\t: never\n\nexport type HexString = `0x${string}`\n\ninterface Eip1193Provider {\n\trequest(request: { method: string; params?: Array<any> | Record<string, any> }): Promise<any>\n\ton(eventName: string | symbol, listener: (...args: any[]) => void): this\n\tremoveListener(eventName: string | symbol, listener: (...args: any[]) => void): this\n}\n\ndeclare global {\n\tinterface Window {\n\t\tethereum?: Eip1193Provider\n\t}\n}\n\nexport type BlockInfo = { blockNumber: bigint; baseFee: bigint; priorityFee: bigint }\nexport type Bundle = { transactions: TransactionList; containsFundingTx: boolean; totalGas: bigint; inputValue: bigint; uniqueSigners: string[] }\nexport type Signers = { burner: Wallet | undefined; burnerBalance: bigint; bundleSigners: { [account: string]: Wallet } }\n\nexport type PromiseState = 'pending' | 'resolved' | 'rejected'\nexport type BundleInfo = { hash: string; state: PromiseState; details: string }\n"]}