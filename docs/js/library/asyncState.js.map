{"version":3,"file":"asyncState.js","sourceRoot":"","sources":["../../ts/library/asyncState.ts"],"names":[],"mappings":"AAAA,OAAO,EAAU,SAAS,EAAE,MAAM,iBAAiB,CAAA;AAQnD,MAAM,UAAU,aAAa;IAC5B,SAAS,yBAAyB;QACjC,2FAA2F;QAC3F,OAAO,gBAAgB,CAAC,IAAI,EAAE,CAAC,MAAM,CAAA;QACrC,oFAAoF;QACpF,gBAAgB,CAAC,KAAK,GAAG,EAAE,MAAM,EAAE,CAAA;QACnC,OAAO,gBAAgB,CAAC,IAAI,EAAE,CAAA;IAC/B,CAAC;IAED,KAAK,UAAU,QAAQ,CAAC,QAA0B;QACjD,MAAM,OAAO,GAAG,yBAAyB,EAAE,CAAA;QAC3C,iHAAiH;QACjH,SAAS,iBAAiB,CAAC,SAA2B;YACrD,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAA;YAC7B,IAAI,MAAM,KAAK,SAAS;gBAAE,OAAM;YAChC,MAAM,CAAC,KAAK,GAAG,SAAS,CAAA;QACzB,CAAC;QACD,IAAI,CAAC;YACJ,MAAM,YAAY,GAAG,EAAE,KAAK,EAAE,SAAkB,EAAE,CAAA;YAClD,iBAAiB,CAAC,YAAY,CAAC,CAAA;YAC/B,MAAM,aAAa,GAAG,MAAM,QAAQ,EAAE,CAAA;YACtC,MAAM,aAAa,GAAG,EAAE,KAAK,EAAE,UAAmB,EAAE,KAAK,EAAE,aAAa,EAAE,CAAA;YAC1E,iBAAiB,CAAC,aAAa,CAAC,CAAA;QACjC,CAAC;QAAC,OAAO,YAAqB,EAAE,CAAC;YAChC,MAAM,KAAK,GAAG,YAAY,YAAY,KAAK,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,4BAA4B,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CAAC,CAAA;YAC/L,MAAM,aAAa,GAAG,EAAE,KAAK,EAAE,UAAmB,EAAE,KAAK,EAAE,CAAA;YAC3D,iBAAiB,CAAC,aAAa,CAAC,CAAA;QACjC,CAAC;IACF,CAAC;IAED,SAAS,KAAK;QACb,MAAM,MAAM,GAAG,yBAAyB,EAAE,CAAC,MAAM,CAAA;QACjD,IAAI,MAAM,KAAK,SAAS;YAAE,OAAM;QAChC,MAAM,CAAC,KAAK,GAAG,EAAE,KAAK,EAAE,UAAU,EAAE,CAAA;IACrC,CAAC;IAED,MAAM,MAAM,GAAG,SAAS,CAAmB,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,CAAA;IACjE,MAAM,gBAAgB,GAAG,SAAS,CAAwC,EAAE,CAAC,CAAA;IAE7E,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAA;AACzE,CAAC","sourcesContent":["import { Signal, useSignal } from '@preact/signals'\nexport type Inactive = { state: 'inactive' }\nexport type Pending = { state: 'pending' }\nexport type Resolved<T> = { state: 'resolved'; value: T }\nexport type Rejected = { state: 'rejected'; error: Error }\nexport type AsyncProperty<T> = Inactive | Pending | Resolved<T> | Rejected\nexport type AsyncState<T> = { value: Signal<AsyncProperty<T>>; waitFor: (resolver: () => Promise<T>) => void; reset: () => void }\n\nexport function useAsyncState<T>(): AsyncState<T> {\n\tfunction getCaptureAndCancelOthers() {\n\t\t// delete previously captured signal so any pending async work will no-op when they resolve\n\t\tdelete captureContainer.peek().result\n\t\t// capture the signal in a new object so we can delete it later if it is interrupted\n\t\tcaptureContainer.value = { result }\n\t\treturn captureContainer.peek()\n\t}\n\n\tasync function activate(resolver: () => Promise<T>) {\n\t\tconst capture = getCaptureAndCancelOthers()\n\t\t// we need to read the property out of the capture every time we look at it, in case it is deleted asynchronously\n\t\tfunction setCapturedResult(newResult: AsyncProperty<T>) {\n\t\t\tconst result = capture.result\n\t\t\tif (result === undefined) return\n\t\t\tresult.value = newResult\n\t\t}\n\t\ttry {\n\t\t\tconst pendingState = { state: 'pending' as const }\n\t\t\tsetCapturedResult(pendingState)\n\t\t\tconst resolvedValue = await resolver()\n\t\t\tconst resolvedState = { state: 'resolved' as const, value: resolvedValue }\n\t\t\tsetCapturedResult(resolvedState)\n\t\t} catch (unknownError: unknown) {\n\t\t\tconst error = unknownError instanceof Error ? unknownError : typeof unknownError === 'string' ? new Error(unknownError) : new Error(`Unknown error occurred.\\n${JSON.stringify(unknownError)}`)\n\t\t\tconst rejectedState = { state: 'rejected' as const, error }\n\t\t\tsetCapturedResult(rejectedState)\n\t\t}\n\t}\n\n\tfunction reset() {\n\t\tconst result = getCaptureAndCancelOthers().result\n\t\tif (result === undefined) return\n\t\tresult.value = { state: 'inactive' }\n\t}\n\n\tconst result = useSignal<AsyncProperty<T>>({ state: 'inactive' })\n\tconst captureContainer = useSignal<{ result?: Signal<AsyncProperty<T>> }>({})\n\n\treturn { value: result, waitFor: resolver => activate(resolver), reset }\n}\n"]}